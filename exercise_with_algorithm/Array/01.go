/*
第350题：两个数组的交集
给定两个数组，编写一个函数来计算它们的交集。
示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]

输出: [2,2]
示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]

输出: [4,9]
说明：

输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
我们可以不考虑输出结果的顺序。
进阶:

如果给定的数组已经排好序呢？将如何优化你的算法呢？
思路：设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组
*/

package main

import (
    "fmt"
    "sort"
)

/*
此题可以看成是一道传统的映射题（map映射），为什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一致。
这样就导致了我们需要知道每个值出现的次数，所以映射关系就成了<元素,出现次数>。剩下的就是顺利成章的解题。
*/

// 1.两个数组无序
func intersect(a1 []int, a2 []int) []int {
    numDict := map[int]int{}
    // value 存字典
    for _, v := range a1 {
        numDict[v] += 1
    }

    i := 0
    for _, v := range a2 {
        // 已存在，则大于 0，key 不存在时为零值（int 零值为 0）
        if numDict[v] > 0 {
            numDict[v] -= 1
            // 如果元素相同，复用存入 a2(节省空间)，并将出现次数减 1
            a2[i] = v
            i++
        }
    }
    return a2[0:i]
}

// 2.两个数组有序
/*
- 对于两个已经排序好数组的题，我们可以很容易想到使用双指针的解法~
<1>设定两个为0的指针，比较两个指针的元素是否相等。 如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组。下图中我们的指针分别指向第一个元素，判断元素相等之后，将相同元素放到空白的数组。
<2>如果两个指针的元素不相等，我们将小的一个指针后移。 图中我们指针移到下一个元素，判断不相等之后，将元素小的指针向后移动，继续进行判断。
<3>反复以上步骤，直到数组结尾
*/
func intersectSort(a1 []int, a2 []int) []int {
    i, j, k := 0, 0, 0
    sort.Ints(a1)
    sort.Ints(a2)
    for i < len(a1) && j < len(a2) {
        if a1[i] == a2[j] {
            // 复用 a2 存储
            a2[k] = a2[j]
            k++
            i++
            j++
        } else if a1[i] < a2[j] {
            i++
        } else {
            j++
        }
    }
    return a2[:k]
}

func main() {
    result := intersect([]int{1, 2, 2, 3}, []int{2, 3, 5, 6})
    fmt.Println(result)

    result = intersectSort([]int{1, 2, 5, 3}, []int{2, 3, 5, 6})
    fmt.Println(result)
}
