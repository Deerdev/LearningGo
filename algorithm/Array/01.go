/*
第350题：两个数组的交集
给定两个数组，编写一个函数来计算它们的交集。
示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]

输出: [2,2]
示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]

输出: [4,9]
说明：

输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
我们可以不考虑输出结果的顺序。
进阶:

如果给定的数组已经排好序呢？将如何优化你的算法呢？
思路：设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组
*/

package main

import (
	"fmt"
	"sort"
)

/*
此题可以看成是一道传统的映射题（map映射），为什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一致。
这样就导致了我们需要知道每个值出现的次数，所以映射关系就成了<元素,出现次数>。剩下的就是顺利成章的解题。
*/

// 1.两个数组无序
func intersect(a1 []int, a2 []int) []int {
	num_dict := map[int]int{}
	// value 存字典
	for _, v := range a1 {
		num_dict[v] += 1
	}

	i := 0
	for _, v := range a2 {
		// 已存在，则大于 0，key 不存在时为零值（int 零值为 0）
		if num_dict[v] > 0 {
			num_dict[v] -= 1
			// 如果元素相同，复用存入 a2(节省空间)，并将出现次数减 1
			a2[i] = v
			i++
		}
	}
	return a2[0:i]
}

// 2.两个数组有序
/*
- 对于两个已经排序好数组的题，我们可以很容易想到使用双指针的解法~
<1>设定两个为0的指针，比较两个指针的元素是否相等。 如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组。下图中我们的指针分别指向第一个元素，判断元素相等之后，将相同元素放到空白的数组。
<2>如果两个指针的元素不相等，我们将小的一个指针后移。 图中我们指针移到下一个元素，判断不相等之后，将元素小的指针向后移动，继续进行判断。
<3>反复以上步骤，直到数组结尾
*/
func intersect_sort(a1 []int, a2 []int) []int {
	i, j, k := 0, 0, 0
	sort.Ints(a1)
	sort.Ints(a2)
	for i < len(a1) && j < len(a2) {
		if a1[i] == a2[j] {
			a2[k] = a2[j]
			k++
			i++
			j++
		} else if a1[i] < a2[j] {
				i++
		} else {
			j++
		}
	}
	return a2[:k]
}

func main() {
	result := intersect([]int{1, 2, 2, 3}, []int{2, 3, 5, 6})
	fmt.Println(result)

	result = intersect_sort([]int{1, 2, 5, 3}, []int{2, 3, 5, 6})
	fmt.Println(result)
}
